## Design Questions
---
Build env requires a specific CWD, and action references a file path. Should the file path be relative to the build env's required CWD, or the CWD of the project directory?

---
__Project and Action Contexts:__

Should these be provided as globals, or as function parameters? (Easier to supply project context as globals compared to action context.)

Idea:

Project context is available under global var `PROJECT`, which points to the topmost entry in the "project stack" stored at `cobble.project_stack`.

The "project stack": When first asked to process a project file cobble will push an initial project context onto the stack.  When a `project_dir(...)` function call is made, the `project_dir` function will push a new project context onto the stack before processing the project file in the requested directory.  Before returning, `project_dir` pops the project context off of the stack, so that the correct project context is active while the rest of the original project is processed.

Available project variables:
- `PROJECT.name`
- `PROJECT.dir`
- `PROJECT.build_envs`
- `PROJECT.tasks`
- `PROJECT.subprojects`

Action contexts are passed in as arguments to functions.

Note on actions: if an action depends on a tool or build env, it must be visible to cobble while computing dependencies.  For this reason, an action can't simply be a function that then invokes commands in various build environments.  The build environment used must be visible outside of the function.

Declaring an action as part of a task might look like this:

```lua
task {
    -- ...,
    actions = {
        { build_env = "poetry", exec = function(self, cxt) end }
    }
}
```

Where `act` is a reference to the action object (table) that defined the action, (in this case, `{ build_env = "poetry", exec = function(act, cxt) end }`,) and `cxt` is the action context.

Action context fields:
- `cxt:tool` - A function that will execute the external tool's action
- `cxt:build_env` - A function that will execute the build environment's action
- `cxt.project_dir` - The directory of the project from which the action request originated

---
__Handling CWD:__
CWD should always be the project directory for actions unless specified.  Initial action invocation will set `cxt.project_dir`, which should propagate to subsequent calls to `cxt:exec` from within that action.

---
__WORKSPACE:__ Like `PROJECT`, there's a `WORKSPACE` global var that provides workspace-level information:
- `WORKSPACE.dir`
- `WORKSPACE.vars`

---

How to handle naming conflicts of tasks, build envs, etc. that are generated by task generators in the same project?

Have the ability to define a subproject with a prefix within a project file.  If we do this, a project will need both a (unique) name and an associated directory.

---
__Action Contexts:__
I'm leaning towards making action implementation functions only take in a single argument, the "action context".  (This means that without a "self" argument, creating a function closure using table properties will be less intuitive, and capturing variables in functions with upvalues will probably become the recommended way.)  What does an action context have in it?

```
action_context = {
    cmd = <a function for invoking the "cmd" tool.  A shortcut for "tool.cmd">
    tool = { <invocation functions for all the tools depended on by the action, keyed by tool names> },
    env = { <invocation functions for all the build envs depended on by the action, keyed by names as they appear in the build_env declaration> },
    args = { <args passed into this actions invocation function by the caller> },
    action = <the original action definition, on which you can access any defined properties, even those not explicitly part of the action schema>,
    project = { dir = <the project directory this action was invoked from. Can be used to set CWD for actions.  Cmd action will use this as the default if cwd arg isn't defined> }
    vars = <(TODO) the variables defined either by config, env var, or CLI arg>
}
```

__Docker Build Environment:__
I'd like to be able to support using a docker container as a build environment.  That is, installing the environment would amount to creating a docker container and installing any build dependencies into it, and actions run in that build environment would be executed with `docker exec`.  Ideally, you'd also be able to run cobble while already inside the docker environment, (e.g in CI or using devcontainers,) in which case running the action in the build environment would just drop the `docker exec` and run the command directly.

I guess a challenge arises when you account for dependencies on other tasks using other environments.  How do those get executed?  Maybe it's best not to support the "I'm already in a container" scenario.  In CI, you could just run the build as usual with a dind container.  With devcontainers, you can [attach to a running container](https://code.visualstudio.com/docs/devcontainers/attach-container) to do development within the container itself.